#!/bin/bash

# awk filter to cut the bytecodes from objdump output
awk_filter='{
	for(i=1; i <=7; i++)
		if($i ~ /^[0-9a-f]+$/)
			printf "%s", $i
}'

# Define a function to display the usage/help message
display_help() {
	echo "Usage: $(basename "$0") [OPTIONS] [FILE]"
	echo "Options:"
	echo "  -h, --help		Display this help message"
	echo "  -bx, --backslash_x	Bytes will be prepended with '\x'"
	echo "  -nb, --nbytes		Prints the total number of bytes of the binary"
}

file=""
bx=false
nb=false

# Parsing options and arguments
while [ "$#" -gt 0 ] && [[ "$1" == -* ]]; do
	case "$1" in
		-h | --help)
			display_help
			exit 0
			;;
		-bx | --backslash_x)
			bx=true
			;;
		-nb | --nbytes)
			nb=true
			;;
		*)
			echo "Invalid option: $1" >&2
			display_help
			exit 1
			;;
	esac
	shift
done


#read from file if provided otherwise read from stdin
if [ $# -eq 0 ]; then
	file="/dev/stdin"
elif [ -n "$1" -a -e "$1" ]; then 
	file="$1"
else	
	echo "assembly file not found"
	exit 1
fi

asm=$(cat "$file")

asm_completed="section .text
global _start
_start:
${asm}"

echo "$asm_completed" > a.temp
nasm -f elf64 -g -F dwarf -o a.temp.o a.temp
#objdump -d --no-addresses -M intel a.temp.o > a.temp.dump 
#awk "$awk_filter" a.temp.dump > a.temp.filtered
objcopy -O binary a.temp.o a.temp.o2
od -An -v -t x1 a.temp.o2 | tr -d ' \n' > a.temp.filtered
filtered=$(cat a.temp.filtered)
filtered_slashx=$(echo "$filtered" | sed 's/../\\x&/g')
total_bytes=$((${#filtered} / 2))

if [ "$bx" = true ]; then
	echo "$filtered_slashx"
else
	echo "$filtered"
fi
if [ "$nb" = true ]; then
	echo "$total_bytes"
fi


rm a.temp
rm a.temp.o
#rm a.temp.dump
rm a.temp.o2
rm a.temp.filtered
