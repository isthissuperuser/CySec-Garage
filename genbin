#!/bin/bash

# awk filter to cut the bytecodes from objdump output
awk_filter='{ 
	for (i=1; i<=NF; i++) {
		if ($i ~ /^[0-9a-f]{2}$/) {
			printf "%s", $i
		}
	}
}
END { printf "\n" }'

# Define a function to display the usage/help message
display_help() {
	echo "Usage: $(basename "$0") [OPTIONS] [FILE]"
	echo "Options:"
	echo "  -h, --help		Display this help message"
	echo "  -bx, --backslash_x	Bytes will be prepended with '\x'"
	echo "  -nb, --nbytes		Prints the total number of bytes of the binary"
}

file=""
bx=false
nb=false

# Parsing options and arguments
while [ "$#" -gt 0 ] && [[ "$1" == -* ]]; do
	case "$1" in
		-h | --help)
			display_help
			exit 0
			;;
		-bx | --backslash_x)
			bx=true
			;;
		-nb | --nbytes)
			nb=true
			;;
		*)
			echo "Invalid option: $1" >&2
			display_help
			exit 1
			;;
	esac
	shift
done


#read from file if provided otherwise read from stdin
if [ $# -eq 0 ]; then
	file="/dev/stdin"
elif [ -n "$1" -a -e "$1" ]; then 
	file="$1"
else	
	echo "assembly file not found"
	exit 1
fi

asm=$(cat "$file")

asm_completed="section .text
global _start
_start:
${asm}"

echo "$asm_completed" > a.temp
nasm -f elf64 -g -F dwarf -o a.temp.o a.temp
rm a.temp
filtered=$(objdump -d --no-addresses -M intel a.temp.o | awk "$awk_filter")
filtered_slashx=$(echo "$filtered" | sed 's/../\\x&/g')
total_bytes=$((${#filtered} / 2))
rm a.temp.o

if [ "$bx" = true ]; then
	echo -n "$filtered_slashx"
else
	echo -n "$filtered"
fi
if [ "$nb" = true ]; then
	echo -e "\n$total_bytes"
fi
